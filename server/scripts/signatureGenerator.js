// This code was to test the signature generation

const secp = require("ethereum-cryptography/secp256k1")
const { toHex, hexToBytes, utf8ToBytes } = require('ethereum-cryptography/utils')
const { keccak256 } = require("ethereum-cryptography/keccak")

//private key generated by generate.js
const privateKeyHex = '23c4e83203c75663c72f0c47e995dadd64ec82afcde65aa110fd6cd923f42ca7'
const ethAddress= '0xb763468c64002ccee2bce2dac9e60bfd4da82893'

const privateKey = hexToBytes(privateKeyHex)

const message  =JSON.stringify({
    to: '0x2',
    amount: 5
})

const msgBytes = utf8ToBytes(message)
const msgHash = keccak256(msgBytes)

async function signature() {
    const [signature, recoveryBit] = await secp.sign(msgHash, privateKey, { recovered: true });
  
    console.log("Mensagem original:", message);
    console.log("Hash da mensagem:", toHex(msgHash));
    console.log("Assinatura:", signature);
    console.log("Assinatura (hex):", toHex(signature));
    console.log("Recovery bit:", recoveryBit);
  
    const publicKey = secp.recoverPublicKey(msgHash, signature, recoveryBit);
    const address = '0x' + toHex(keccak256(publicKey.slice(1)).slice(-20));
  
    console.log("Endere√ßo derivado da assinatura:", address);
  }

  signature()



